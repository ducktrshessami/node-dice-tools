{"version":3,"sources":["../src/error.ts","../src/validate.ts","../src/roll.ts","../src/query.ts"],"sourcesContent":["class CustomError extends Error {\n    constructor(message?: string) {\n        super(message);\n        this.name = this.constructor.name;\n    }\n}\n\nexport class RollQueryError extends CustomError { }\n","import { RollQueryError } from \"./error\";\n\nexport const RollQueryPattern = /^(?:[+-]?\\s*(?:\\d*d)?\\d+)(?:\\s*[+-]\\s*(?:\\d*d)?\\d+)*$/i;\n\n/**\n * Includes the `sign`, `count`, and `sides` groups\n * \n * If `count` is null, the item is a constant of value `sides`\n */\nexport const RollQueryItemPattern = /(?<sign>[+-])?\\s*(?:(?<count>\\d*)d)?(?<sides>\\d+)/gi;\n\nfunction validateDiceAttribute(n: number, label: string): void {\n    if (n < 1 || Math.floor(n) !== n) {\n        const value = typeof n === \"string\" ? `'${n}'` : n;\n        throw new RollQueryError(`${label} must be a positive whole number. Received ${value}`);\n    }\n}\n\nexport function validateDiceAttributes(count: number, sides: number): void {\n    validateDiceAttribute(count, \"Dice count\");\n    validateDiceAttribute(sides, \"Sides\");\n}\n","import { validateDiceAttributes } from \"./validate\";\n\nexport function rawRoll(count: number, sides: number): number {\n    let result = 0;\n    for (let i = 0; i < count; i++) {\n        result += Math.ceil(Math.random() * sides);\n    }\n    return result;\n}\n\nexport function roll(count: number, sides: number): number {\n    validateDiceAttributes(count, sides);\n    return rawRoll(count, sides);\n}\n","import { rawRoll } from \"./roll\";\nimport {\n    RollQueryItemPattern,\n    RollQueryPattern,\n    validateDiceAttributes\n} from \"./validate\";\n\nexport class RollQueryItem {\n    public lastResult: number | null;\n\n    constructor(\n        public count: number,\n        public sides: number,\n        public negative: boolean = false\n    ) {\n        this.lastResult = null;\n        validateDiceAttributes(count, sides);\n    }\n\n    private get rawMax(): number {\n        return this.count * this.sides;\n    }\n\n    get min(): number {\n        return this.negative ? this.rawMax * -1 : this.count;\n    }\n\n    get max(): number {\n        return this.negative ? this.count * -1 : this.rawMax;\n    }\n\n    roll(): number {\n        this.lastResult = rawRoll(this.count, this.sides) * (this.negative ? -1 : 1);\n        return this.lastResult;\n    }\n\n    toString(forceSign: boolean = false): string {\n        const sign = this.negative ? \"-\" : forceSign ? \"+\" : \"\";\n        return `${sign}${this.count}d${this.sides}`;\n    }\n}\n\nexport type RollQueryOptions = {\n    items?: RollQueryItem[];\n    constant?: number;\n};\n\nexport class RollQuery {\n    items: RollQueryItem[];\n    constant: number;\n\n    constructor({ items, constant }: RollQueryOptions = {}) {\n        this.items = items ?? [];\n        this.constant = constant ?? 0;\n    }\n\n    static parse(query: string): RollQuery | null {\n        if (!RollQueryPattern.test(query)) {\n            return null;\n        }\n        const q = new RollQuery();\n        const matches = query.matchAll(RollQueryItemPattern);\n        for (const match of matches) {\n            if (match.groups?.count == null) {\n                q.constant += parseInt(match.groups!.sides) * (match.groups!.sign === \"-\" ? -1 : 1);\n            }\n            else try {\n                q.items.push(new RollQueryItem(\n                    match.groups.count ? parseInt(match.groups.count) : 1,\n                    parseInt(match.groups.sides),\n                    match.groups.sign === \"-\"\n                ));\n            }\n            catch {\n                return null;\n            }\n        }\n        return q;\n    }\n\n    get min(): number {\n        return this.items.reduce((min, item) => min + item.min, this.constant);\n    }\n\n    get max(): number {\n        return this.items.reduce((max, item) => max + item.max, this.constant);\n    }\n\n    get lastResult(): number | null {\n        let result = this.constant;\n        for (const item of this.items) {\n            if (item.lastResult == null) {\n                return null;\n            }\n            else {\n                result += item.lastResult;\n            }\n        }\n        return result;\n    }\n\n    roll(): number {\n        return this.constant + this.items.reduce((result, item) => result + item.roll(), 0);\n    }\n\n    toString(): string {\n        const constant = this.constant ? (this.constant < 0 ? \"-\" : \"+\") + this.constant : \"\";\n        if (!this.items.length) {\n            return constant;\n        }\n        let query = this.items[0].toString();\n        for (let i = 1; i < this.items.length; i++) {\n            query += this.items[i].toString(true);\n        }\n        return query + constant;\n    }\n}\n"],"mappings":"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","names":[]}